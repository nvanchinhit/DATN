// backend/socket/chatSocket.js

const { promiseDb } = require('../config/db.config');

module.exports = (io) => {
  io.on('connection', (socket) => {
    console.log('üü¢ Ng∆∞·ªùi d√πng ƒë√£ k·∫øt n·ªëi:', socket.id);

    // 1. B√°c sƒ© ƒëƒÉng k√Ω
    socket.on('registerDoctor', ({ doctor_id }) => {
      socket.doctor_id = doctor_id;
      console.log(`üë®‚Äç‚öïÔ∏è B√°c sƒ© ${doctor_id} ƒë√£ ƒëƒÉng k√Ω`);
    });

    // 2. B√°c sƒ© tham gia ph√≤ng chat
    socket.on('joinRoom', async ({ room_id, role }) => {
      if (!room_id) return;

      console.log(`üîî ${role} ƒë√£ tham gia room_${room_id}`);
      socket.join(`room_${room_id}`);

      if (role === 'admin') {
        socket.isAdmin = true;
      }

      // üî• N·∫æU L√Ä B√ÅC Sƒ®, G·ª¨I TH√îNG B√ÅO CHO NG∆Ø·ªúI D√ôNG
      if (role === 'doctor') {
        try {
          // L·∫•y th√¥ng tin b√°c sƒ©
          const [doctorInfo] = await promiseDb.query(
            'SELECT name FROM doctors WHERE id = ?',
            [socket.doctor_id]
          );

          if (doctorInfo.length > 0) {
            const doctorName = doctorInfo[0].name;
            
            // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ trong ph√≤ng (bao g·ªìm customer)
            io.to(`room_${room_id}`).emit('doctorJoined', {
              room_id,
              doctor_id: socket.doctor_id,
              doctor_name: doctorName,
              message: `üë®‚Äç‚öïÔ∏è B√°c sƒ© ${doctorName} ƒë√£ tham gia ph√≤ng chat v√† s·∫µn s√†ng t∆∞ v·∫•n!`,
              timestamp: new Date().toISOString()
            });

            // üî• TH√îNG B√ÅO CHO ADMIN V·ªÄ VI·ªÜC B√ÅC Sƒ® JOIN
            io.to('admin').emit('doctorJoinedAdmin', {
              room_id,
              doctor_id: socket.doctor_id,
              doctor_name: doctorName,
              message: `üë®‚Äç‚öïÔ∏è B√°c sƒ© ${doctorName} ƒë√£ tham gia ph√≤ng #${room_id}`,
              timestamp: new Date().toISOString()
            });

            console.log(`üë®‚Äç‚öïÔ∏è B√°c sƒ© ${doctorName} ƒë√£ tham gia ph√≤ng ${room_id}`);
          }
        } catch (err) {
          console.error('‚ùå L·ªói khi l·∫•y th√¥ng tin b√°c sƒ©:', err);
        }
      }
    });

    // 3. Admin ph√¢n c√¥ng b√°c sƒ© v√†o ph√≤ng
    socket.on('assignDoctor', async ({ room_id, doctor_id }) => {
      if (!room_id || !doctor_id) {
        console.warn('‚ö†Ô∏è Thi·∫øu th√¥ng tin khi g√°n b√°c sƒ©');
        return;
      }

      try {
        // üî• C·∫¨P NH·∫¨T DATABASE
        await promiseDb.query(
          'UPDATE chat_rooms SET assigned_doctor_id = ?, updated_at = NOW() WHERE id = ?',
          [doctor_id, room_id]
        );

        // üî• TH√îNG B√ÅO CHO PH√íNG CHAT
        io.to(`room_${room_id}`).emit('doctorAssigned', { doctor_id });
        
        // üî• TH√îNG B√ÅO CHO T·∫§T C·∫¢ ADMIN
        io.to('admin').emit('doctorAssignedNotification', {
          room_id,
          doctor_id,
          timestamp: new Date().toISOString()
        });
        
        // üî• C·∫¨P NH·∫¨T DANH S√ÅCH PH√íNG CHO T·∫§T C·∫¢ ADMIN
        const [roomInfo] = await promiseDb.query(`
          SELECT cr.id, cr.customer_id, cr.assigned_doctor_id, cr.updated_at,
                 cu.name AS customer_name
          FROM chat_rooms cr
          LEFT JOIN customers cu ON cr.customer_id = cu.id
          WHERE cr.id = ?
        `, [room_id]);
        
        if (roomInfo.length > 0) {
          io.to('admin').emit('roomUpdated', roomInfo[0]);
        }
        
        console.log(`üë®‚Äç‚öïÔ∏è G√°n b√°c sƒ© ${doctor_id} cho ph√≤ng ${room_id} th√†nh c√¥ng!`);
      } catch (err) {
        console.error('‚ùå L·ªói khi g√°n b√°c sƒ©:', err);
      }
    });

    // 4. B√°c sƒ© ho·∫∑c admin g·ª≠i tin nh·∫Øn
    socket.on('replyMessage', async ({ room_id, sender_id, sender_type, message }) => {
      if (!room_id || !sender_id || !sender_type || !message?.trim()) {
        console.warn('‚ö†Ô∏è D·ªØ li·ªáu replyMessage kh√¥ng h·ª£p l·ªá');
        return;
      }

      try {
        // H·∫°n ch·∫ø: Admin ch·ªâ ƒë∆∞·ª£c xem khi ph√≤ng ƒë√£ g√°n b√°c sƒ©
        const [[room]] = await promiseDb.query(
          'SELECT assigned_doctor_id FROM chat_rooms WHERE id = ? LIMIT 1',
          [room_id]
        );
        if (!room) {
          console.warn('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ph√≤ng:', room_id);
          return;
        }
        const isAdminSocket = socket.isAdmin === true || sender_type === 'admin';
        if (isAdminSocket && room.assigned_doctor_id) {
          socket.emit('messageRejected', {
            reason: 'admin_read_only',
            message: 'Ph√≤ng ƒë√£ c√≥ b√°c sƒ©, admin ch·ªâ ƒë∆∞·ª£c xem.',
            timestamp: new Date().toISOString(),
          });
          return;
        }
        // B·∫£o v·ªá: Ch·ªâ b√°c sƒ© ƒë∆∞·ª£c g√°n m·ªõi ƒë∆∞·ª£c nh·∫Øn trong ph√≤ng ƒë√£ g√°n
        if (sender_type === 'doctor' && room.assigned_doctor_id && Number(room.assigned_doctor_id) !== Number(sender_id)) {
          socket.emit('messageRejected', {
            reason: 'doctor_not_assigned',
            message: 'B·∫°n kh√¥ng ph·∫£i b√°c sƒ© ƒë∆∞·ª£c g√°n cho ph√≤ng n√†y.',
            timestamp: new Date().toISOString(),
          });
          return;
        }

        await promiseDb.query(
          'INSERT INTO chat_messages (room_id, sender_id, sender_type, message) VALUES (?, ?, ?, ?)',
          [room_id, sender_id, sender_type, message]
        );

        await promiseDb.query(
          'UPDATE chat_rooms SET updated_at = NOW() WHERE id = ?',
          [room_id]
        );

        const newMsg = {
          room_id,
          sender_id,
          sender_type,
          message,
          created_at: new Date().toISOString(),
        };

        io.to(`room_${room_id}`).emit('newMessage', newMsg);
        
        // üî• TH√îNG B√ÅO CHO ADMIN V·ªÄ TIN NH·∫ÆN M·ªöI
        io.to('admin').emit('newMessageNotification', {
          room_id,
          sender_id,
          message: message.substring(0, 50) + (message.length > 50 ? '...' : ''),
          timestamp: new Date().toISOString()
        });
      } catch (err) {
        console.error('‚ùå L·ªói khi g·ª≠i replyMessage:', err);
      }
    });

    // 4.1. Kh√°ch h√†ng g·ª≠i tin nh·∫Øn
    socket.on('sendMessage', async (data) => {
      const { customer_id, room_id, message } = data;

      if (!room_id || !message?.trim() || !customer_id) {
        console.warn('‚ö†Ô∏è D·ªØ li·ªáu g·ª≠i kh√¥ng h·ª£p l·ªá:', data);
        return;
      }

      try {
        // C·∫≠p nh·∫≠t th·ªùi gian ph√≤ng chat
        await promiseDb.query(
          'UPDATE chat_rooms SET updated_at = NOW() WHERE id = ?',
          [room_id]
        );

        // L∆∞u tin nh·∫Øn v√†o DB
        await promiseDb.query(
          'INSERT INTO chat_messages (room_id, sender_id, sender_type, message) VALUES (?, ?, ?, ?)',
          [room_id, customer_id, 'customer', message]
        );

        // G·ª≠i tin nh·∫Øn t·ªõi ph√≤ng
        const newMsg = {
          room_id,
          sender_id: customer_id,
          sender_type: 'customer',
          message,
          created_at: new Date().toISOString(),
        };

        io.to(`room_${room_id}`).emit('newMessage', newMsg);
        
        // üî• TH√îNG B√ÅO CHO ADMIN V·ªÄ TIN NH·∫ÆN M·ªöI
        io.to('admin').emit('newMessageNotification', {
          room_id,
          customer_id,
          message: message.substring(0, 50) + (message.length > 50 ? '...' : ''),
          timestamp: new Date().toISOString()
        });
        
        // üî• C·∫¨P NH·∫¨T DANH S√ÅCH PH√íNG CHO T·∫§T C·∫¢ ADMIN
        const [roomInfo] = await promiseDb.query(`
          SELECT cr.id, cr.customer_id, cr.assigned_doctor_id, cr.updated_at,
                 c.name AS customer_name
          FROM chat_rooms cr
          LEFT JOIN customers c ON cr.customer_id = c.id
          WHERE cr.id = ?
        `, [room_id]);
        
        if (roomInfo.length > 0) {
          io.to('admin').emit('roomUpdated', roomInfo[0]);
        }
        
        console.log('üì® G·ª≠i tin nh·∫Øn th√†nh c√¥ng:', newMsg);
      } catch (err) {
        console.error('‚ùå L·ªói khi g·ª≠i tin nh·∫Øn:', err);
      }
    });

    // 5. Admin r·ªùi kh·ªèi ph√≤ng chat
    socket.on('leaveRoom', ({ room_id, role }) => {
      if (!room_id) return;
      
      console.log(`üîå ${role} r·ªùi kh·ªèi ph√≤ng ${room_id}`);
      socket.leave(`room_${room_id}`);
    });

    // 6. Admin ƒëƒÉng k√Ω nh·∫≠n tin nh·∫Øn m·ªõi
    socket.on('registerAdmin', () => {
      socket.join('admin');
      socket.isAdmin = true;
      console.log('üì© Admin ƒë√£ tham gia k√™nh nh·∫≠n tin nh·∫Øn m·ªõi');
      
      // üî• G·ª¨I NGAY DANH S√ÅCH PH√íNG HI·ªÜN T·∫†I CHO ADMIN M·ªöI
      socket.emit('adminRegistered', { message: 'Admin ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω th√†nh c√¥ng' });
    });

    // 7. Admin l·∫•y danh s√°ch t·∫•t c·∫£ room (c·∫£ ƒë√£ v√† ch∆∞a c√≥ b√°c sƒ©)
    socket.on('getAllRooms', async () => {
      try {
        const [rows] = await promiseDb.query(`
          SELECT 
            r.*, 
            d.name AS doctor_name,
            c.name AS customer_name
          FROM chat_rooms r
          LEFT JOIN doctors d ON r.assigned_doctor_id = d.id
          LEFT JOIN customers c ON r.customer_id = c.id
          ORDER BY r.updated_at DESC
        `);
        socket.emit('roomList', rows);
      } catch (err) {
        console.error('‚ùå L·ªói khi l·∫•y t·∫•t c·∫£ room:', err);
      }
    });

    // 8. Admin l·∫•y tin nh·∫Øn c·ªßa m·ªôt room (n·∫øu mu·ªën l·∫•y qua socket thay v√¨ REST API)
    socket.on('getRoomMessages', async (room_id) => {
      try {
        const [rows] = await promiseDb.query(
          'SELECT * FROM chat_messages WHERE room_id = ? ORDER BY created_at ASC',
          [room_id]
        );
        socket.emit('roomMessages', rows);
      } catch (err) {
        console.error('‚ùå L·ªói khi l·∫•y tin nh·∫Øn ph√≤ng:', err);
      }
    });

    // 9. Ng·∫Øt k·∫øt n·ªëi
    socket.on('disconnect', () => {
      console.log('üîå Ng∆∞·ªùi d√πng ƒë√£ ng·∫Øt k·∫øt n·ªëi:', socket.id);
    });
  });
};